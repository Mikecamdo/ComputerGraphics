<!DOCTYPE html>

<html>
    <script id="vertex-shader" type="x-shader/x-vertex">
        #version 300 es

        in vec4 aPosition;

        in vec2 aTexCoord;
        out vec2 vTexCoord;

        void main()
        {
            vTexCoord = vec2(1.0 - aTexCoord.x, aTexCoord.y); // flips the orientation of the live video feed
            gl_Position = aPosition;
        }
    </script>

    <script id="fragment-shader-1" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            if (distortionFilterType == 1) { // none
                fColor = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                fColor = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        fColor = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        fColor = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        fColor = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        fColor = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        fColor = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        fColor = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        fColor = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        fColor = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                fColor = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                fColor = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    fColor = videoColor;
                } else {
                    fColor = backgroundColor;
                }
            }
        }
    </script>

    <script id="fragment-shader-2" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            vec3 w = vec3(0.2125, 0.7154, 0.0721);
            vec4 color;

            if (distortionFilterType == 1) { // none
                color = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                color = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                color = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                color = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    color = videoColor;
                } else {
                    color = backgroundColor;
                }
            }
            
            float lum = dot(color.rgb, w);
            fColor = vec4(lum, lum, lum, 1.0);
        }
    </script>

    <script id="fragment-shader-3" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            vec4 color;
            
            if (distortionFilterType == 1) { // none
                color = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                color = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                color = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                color = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    color = videoColor;
                } else {
                    color = backgroundColor;
                }
            }
            
            fColor = vec4(1.0 - color.r, 1.0 - color.g, 1.0 - color.b, 1.0);
        }
    </script>

    <script id="fragment-shader-4" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            vec3 w = vec3(0.2125, 0.7154, 0.0721);
            vec4 color;
            
            if (distortionFilterType == 1) { // none
                color = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                color = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                color = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                color = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    color = videoColor;
                } else {
                    color = backgroundColor;
                }
            }
            
            float t = 3.0;

            vec3 Q = (1.0 - t) * dot(color.rgb, w) + t * color.rgb;
            fColor = vec4(Q, 1.0);
        }
    </script>

    <script id="fragment-shader-5" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            // sepia filter, as described here: https://stackoverflow.com/questions/1061093/how-is-a-sepia-tone-created
            vec4 color;
            
            if (distortionFilterType == 1) { // none
                color = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                color = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                color = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                color = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    color = videoColor;
                } else {
                    color = backgroundColor;
                }
            }
            
            vec3 sepia = vec3(0.393 * color.r + 0.769 * color.g + 0.189 * color.b,
                              0.349 * color.r + 0.686 * color.g + 0.168 * color.b,
                              0.272 * color.r + 0.534 * color.g + 0.131 * color.b);

            fColor = vec4(sepia, 1.0);
        }
    </script>

    <script id="fragment-shader-6" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            vec4 color;
            
            if (distortionFilterType == 1) { // none
                color = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                color = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                color = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                color = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    color = videoColor;
                } else {
                    color = backgroundColor;
                }
            }

            float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
            float threshold = 0.5;

            if (gray > threshold) {
                fColor = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
                fColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
        }
    </script>

    <script id="fragment-shader-7" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            vec4 color;
            
            if (distortionFilterType == 1) { // none
                color = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                color = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                color = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                color = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    color = videoColor;
                } else {
                    color = backgroundColor;
                }
            }

            float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));

            float clusteredDotScreen[64] = float[](
                62.0, 57.0, 48.0, 36.0, 37.0, 49.0, 58.0, 63.0,
                56.0, 47.0, 35.0, 21.0, 22.0, 38.0, 50.0, 59.0,
                46.0, 34.0, 20.0, 10.0, 11.0, 23.0, 39.0, 51.0,
                33.0, 19.0, 9.0 , 3.0 , 0.0 , 4.0 , 12.0, 24.0,
                32.0, 18.0, 8.0 , 2.0 , 1.0 , 5.0 , 13.0, 25.0,
                45.0, 31.0, 17.0, 7.0 , 6.0 , 14.0, 26.0, 40.0,
                55.0, 44.0, 30.0, 16.0, 15.0, 27.0, 41.0, 52.0,
                61.0, 54.0, 43.0, 29.0, 28.0, 42.0, 53.0, 60.0
            );

            int col = int(mod(gl_FragCoord.x, 8.0));
            int row = int(mod(gl_FragCoord.y, 8.0));
            int index = row * 8 + col;

            float threshold = clusteredDotScreen[index];
            threshold /= 64.0;
 
            if (gray > threshold) {
                fColor = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
                fColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
        }
    </script>

    <script id="fragment-shader-8" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec2 vTexCoord;
        out vec4 fColor;

        uniform int distortionFilterType;
        uniform int reflectionType;
        uniform int blurStrength;

        uniform float amplitude;
        uniform float frequency;
        uniform float distortionCoefficient;

        uniform sampler2D uTexMap;
        uniform sampler2D uBackgroundTexture;

        void main()
        {
            vec4 color;
            
            if (distortionFilterType == 1) { // none
                color = texture(uTexMap, vTexCoord);
            } else if (distortionFilterType == 2) { // blurry
                // texelSize calculated off of image dimensions (640x360)
                vec2 texelSize = vec2(1.0/640.0, 1.0/360.0);        
                vec3 blur = vec3(0.0, 0.0, 0.0);

                // Applies a kernel to blur the image
                for (int i = -blurStrength; i <= blurStrength; i++) {
                    for (int j = -blurStrength; j <= blurStrength; j++) {
                        blur += texture(uTexMap, vTexCoord + vec2(i, j) * texelSize).rgb;
                    }
                }

                // normalizes the result
                blur /= ((float(blurStrength) * 2.0 + 1.0) * (float(blurStrength) * 2.0 + 1.0));

                color = vec4(blur, 1.0);
            } else if (distortionFilterType == 3) { // reflection
                if (reflectionType == 1) {
                    if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else if (reflectionType == 2) {
                    if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                } else {
                    if (vTexCoord.x < 0.5 && vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, 1.0 - vTexCoord.y));
                    } else if (vTexCoord.x < 0.5) {
                        color = texture(uTexMap, vec2(1.0 - vTexCoord.x, vTexCoord.y));
                    } else if (vTexCoord.y < 0.5) {
                        color = texture(uTexMap, vec2(vTexCoord.x, 1.0 - vTexCoord.y));
                    } else {
                        color = texture(uTexMap, vTexCoord);
                    }
                }
            } else if (distortionFilterType == 4) { // wave distortion
                vec2 newCoord = vTexCoord;
                newCoord.y += amplitude * sin(newCoord.x * frequency);

                color = texture(uTexMap, newCoord);
            } else if (distortionFilterType == 5) { // barrel distortion           
                // inspired by formula found at: https://stackoverflow.com/questions/6199636/formulas-for-barrel-pincushion-distortion
                
                // get radius from fragment to the center of the image
                vec2 center = vec2(0.5, 0.5);
                float normalRadius = length(vTexCoord - center);
                
                // calculate new radius
                float distortedRadius = distortionCoefficient * pow(normalRadius, 2.0);
                
                // calculate new coordinate
                vec2 distortedCoord = center + normalize(vTexCoord - center) * distortedRadius;

                color = texture(uTexMap, distortedCoord);
            } else { // distortionFilterType == 6 or 7 (gorilla or christmas hat)
                vec4 backgroundColor = texture(uBackgroundTexture, vTexCoord);
                vec4 videoColor = texture(uTexMap, vTexCoord);

                if (backgroundColor.g - 0.1 > (backgroundColor.r + backgroundColor.b)) {
                    color = videoColor;
                } else {
                    color = backgroundColor;
                }
            }

            float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));

            float bayerDotScreen[64] = float[](
                21.0, 37.0, 25.0, 41.0, 22.0, 38.0, 26.0, 42.0,
                53.0, 5.0 , 57.0, 9.0 , 54.0, 6.0 , 58.0, 10.0,
                29.0, 45.0, 17.0, 33.0, 30.0, 46.0, 18.0, 34.0,
                61.0, 13.0, 49.0, 1.0 , 62.0, 14.0, 50.0, 2.0 ,
                23.0, 39.0, 27.0, 43.0, 20.0, 36.0, 24.0, 40.0,
                55.0, 7.0 , 59.0, 11.0, 52.0, 4.0 , 56.0, 8.0 ,
                31.0, 47.0, 19.0, 35.0, 28.0, 44.0, 16.0, 32.0,
                63.0, 15.0, 51.0, 3.0 , 60.0, 12.0, 48.0, 0.0
            );

            int col = int(mod(gl_FragCoord.x, 8.0));
            int row = int(mod(gl_FragCoord.y, 8.0));
            int index = row * 8 + col;

            float threshold = bayerDotScreen[index];
            threshold /= 64.0;
 
            if (gray > threshold) {
                fColor = vec4(1.0, 1.0, 1.0, 1.0);
            } else {
                fColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
        }
    </script>

    <script type="text/javascript" src="../Common/initShaders.js"></script>
    <script type="text/javascript" src="CG_F23_Program3_DohertyMichael.js"></script>
    <script type="text/javascript" src="CG_F23_Program3_DohertyMichael_ImageData.js"></script>

    <body>
        <div>
            <canvas id="gl-canvas" width="640" height="360">
                Oops ... your browser doesn't support the HTML5 canvas element
            </canvas>
        
            <video style="display: none;"></video>        
        </div>

        <div>
            <label for="colorFilter">Choose Color Filter:</label>

            <select name="colorFilter" id="colorFilter">
                <option selected value="1">None</option>
                <option value="2">Grayscale</option>
                <option value="3">Image Negative</option>
                <option value="4">Saturated</option>
                <option value="5">Sepia</option>
                <option value="6">Constant Threshold Halftoning</option>
                <option value="7">Clustered Dot Screen</option>
                <option value="8">Bayer Dot Screen</option>
            </select>
        </div>

        <div>
            <label for="distortionFilter">Choose Geometric Distortion Filter:</label>

            <select name="distortionFilter" id="distortionFilter">
                <option selected value="1">None</option>
                <option value="2">Blurry</option>
                <option value="3">Reflection</option>
                <option value="4">Wave Distortion</option>
                <option value="5">Barrel Distortion</option>
                <option value="6">Gorilla</option>
                <option value="7">Christmas Hat</option>
            </select>
        </div>
        
        <div id="reflectionChoice" style="display: none;">
            <label for="reflectionType">Reflection Type:</label>

            <select name="reflectionType" id="reflectionType">
                <option selected value="1">Vertical</option>
                <option value="2">Horizontal</option>
                <option value="3">Vertical and Horizontal</option>
            </select>
        </div>

        <div id="blurChoice" style="display: none;">
            <label for="blurStrength">Blur Strength:</label>
            <input name="blurStrength" id="blurStrength" type="range"
            min="0" max="20" step="1" value="7" />
        </div>

        <div id="waveChoices" style="display: none;">
            <label for="amplitude">Amplitude:</label>
            <input name="amplitude" id="amplitude" type="range"
            min="0.0" max="1.0" step="0.01" value="0.2" />

            <label for="frequency">Frequency:</label>
            <input name="frequency" id="frequency" type="range"
            min="0.0" max="25.0" step="0.1" value="10.0" />
        </div>

        <div id="distortionChoice" style="display: none;">
            <label for="distortionCoefficient">Distortion Coefficient:</label>
            <input name="distortionCoefficient" id="distortionCoefficient" type="range"
            min="0.0" max="20.0" step="0.1" value="1.0" />
        </div>
    </body>
</html>